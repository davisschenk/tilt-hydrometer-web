{
  "_note": "Web frontend backlog. Backend backlog archived in prd-backend.json.",
  "project_meta": {
    "name": "tilt-hydrometer-web",
    "version": "0.1.0",
    "ralph_type": "opencode",
    "opencode_session_id": "ralph-deep-init-web-2026-02-14"
  },
  "backlog": [
    {
      "group": "Project-Setup",
      "feature": "Initialize Vite React TypeScript project",
      "description": "Create the web/ directory using Vite with React and TypeScript template. Configure strict TypeScript via tsconfig.json. Install core dependencies: react-router-dom, @tanstack/react-query, recharts, date-fns, lucide-react. Set up VITE_API_URL environment variable with default to http://localhost:8000/api/v1. Verify the dev server starts with npm run dev.",
      "acceptance_criteria": [
        "web/ directory exists with Vite React TS project \u2014 verify with ls web/package.json and web/tsconfig.json",
        "TypeScript strict mode enabled in tsconfig.json \u2014 verify by reading compilerOptions.strict = true",
        "All core dependencies installed (react-router-dom, @tanstack/react-query, recharts, date-fns, lucide-react) \u2014 verify with npm ls in web/",
        "VITE_API_URL env var configured with default \u2014 verify by reading web/.env or web/src/lib/api.ts",
        "npm run dev starts Vite dev server without errors \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Project-Setup",
      "feature": "Configure TailwindCSS v4 and shadcn/ui",
      "description": "Install and configure TailwindCSS v4 in the Vite project. Initialize shadcn/ui with 'npx shadcn@latest init' choosing New York style, zinc base color, and CSS variables. Install initial shadcn components: button, card, input, label, badge, separator, dropdown-menu, dialog, table, toast, sonner. Verify Tailwind classes render correctly.",
      "acceptance_criteria": [
        "TailwindCSS v4 is installed and configured \u2014 verify by checking web/package.json and that utility classes render in browser",
        "shadcn/ui initialized with components.json config \u2014 verify by reading web/components.json",
        "All listed shadcn components installed in web/src/components/ui/ \u2014 verify with ls web/src/components/ui/",
        "A test page with a shadcn Button renders correctly \u2014 verify by viewing in browser"
      ],
      "passes": true
    },
    {
      "group": "Project-Setup",
      "feature": "TypeScript API types mirroring shared crate DTOs",
      "description": "Create web/src/types/ directory with TypeScript interfaces that mirror the Rust shared crate DTOs. Define: TiltColor (string union of 8 colors), TiltReading, CreateReadingsBatch, BrewStatus ('Active' | 'Completed' | 'Archived'), CreateBrew, UpdateBrew, BrewResponse, CreateHydrometer, UpdateHydrometer, HydrometerResponse, ReadingResponse, ReadingsQuery. All field names in camelCase matching the serde serialization.",
      "acceptance_criteria": [
        "web/src/types/index.ts exports all DTO interfaces \u2014 verify by reading file",
        "TiltColor is a union type of 8 color strings \u2014 verify by reading type definition",
        "BrewResponse interface has all fields matching Rust BrewResponse (id, name, style, og, fg, targetFg, abv, status, startDate, endDate, notes, hydrometerId, createdAt, updatedAt, latestReading) \u2014 verify by reading interface",
        "HydrometerResponse interface matches Rust HydrometerResponse \u2014 verify by reading interface",
        "ReadingResponse interface matches Rust ReadingResponse \u2014 verify by reading interface",
        "npm run build succeeds with no TypeScript errors \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Project-Setup",
      "feature": "API client and TanStack Query provider setup",
      "description": "Create web/src/lib/api.ts with a typed fetch wrapper that prepends VITE_API_URL to all requests, handles JSON parsing, and throws typed errors for non-2xx responses. Create web/src/lib/query-client.ts configuring a QueryClient with sensible defaults (staleTime 30s, retry 1). Wrap the app in QueryClientProvider in main.tsx. Create web/src/hooks/use-brews.ts, use-hydrometers.ts, use-readings.ts with TanStack Query hooks for each resource's CRUD operations.",
      "acceptance_criteria": [
        "web/src/lib/api.ts exports typed fetch functions (apiGet, apiPost, apiPut, apiDelete) \u2014 verify by reading file",
        "API client reads VITE_API_URL from import.meta.env \u2014 verify by reading file",
        "QueryClientProvider wraps the app in main.tsx \u2014 verify by reading file",
        "useBrews() hook returns { data, isLoading, error } from GET /brews \u2014 verify by reading hook file",
        "useHydrometers() hook exists with list/create/update/delete mutations \u2014 verify by reading hook file",
        "useReadings() hook accepts query params (brewId, since, until, limit) \u2014 verify by reading hook file",
        "npm run build succeeds \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Project-Setup",
      "feature": "React Router configuration with route structure",
      "description": "Set up React Router v7 in web/src/main.tsx with BrowserRouter. Create route structure: / (dashboard), /brews (brew list), /brews/:id (brew detail), /brews/new (create brew), /hydrometers (hydrometer list). Create placeholder page components in web/src/pages/ for each route. Configure a 404 catch-all route.",
      "acceptance_criteria": [
        "BrowserRouter configured in main.tsx \u2014 verify by reading file",
        "Routes defined for /, /brews, /brews/:id, /brews/new, /hydrometers \u2014 verify by reading router config",
        "Placeholder page components exist in web/src/pages/ (dashboard.tsx, brew-list.tsx, brew-detail.tsx, brew-new.tsx, hydrometer-list.tsx) \u2014 verify with ls",
        "404 catch-all route renders a not-found page \u2014 verify by reading router config",
        "Navigation between routes works \u2014 verify by clicking links in browser"
      ],
      "passes": true
    },
    {
      "group": "Layout-Navigation",
      "feature": "App shell with sidebar navigation",
      "description": "Create web/src/components/layout/app-shell.tsx as the root layout component. It should render a fixed sidebar on the left (collapsible on mobile) and a main content area. The sidebar contains the app logo/title ('Tilt Dashboard'), navigation links (Dashboard, Brews, Hydrometers), and a footer with version info. Use shadcn/ui components and Lucide icons (LayoutDashboard, Beer, Thermometer). The layout should use an Outlet from React Router for nested route rendering.",
      "acceptance_criteria": [
        "AppShell component renders sidebar + main content area \u2014 verify by viewing in browser",
        "Sidebar has nav links: Dashboard (/), Brews (/brews), Hydrometers (/hydrometers) \u2014 verify by reading source and clicking links",
        "Active route is visually highlighted in sidebar \u2014 verify by navigating and checking active state styling",
        "Lucide icons rendered next to each nav label \u2014 verify by viewing in browser",
        "React Router Outlet renders child route content \u2014 verify by navigating between routes"
      ],
      "passes": true
    },
    {
      "group": "Layout-Navigation",
      "feature": "Responsive mobile navigation",
      "description": "Make the sidebar responsive: on screens below md breakpoint, the sidebar collapses into a hamburger menu button in a top header bar. Clicking the hamburger opens a Sheet (shadcn/ui) sliding panel with the same navigation links. The Sheet closes on link click or outside click. Add the shadcn Sheet component if not already installed.",
      "acceptance_criteria": [
        "Sidebar hidden on mobile (below md breakpoint) \u2014 verify by resizing browser window",
        "Hamburger menu button appears in top header on mobile \u2014 verify by viewing at mobile width",
        "Clicking hamburger opens Sheet with nav links \u2014 verify by clicking in browser",
        "Sheet closes when a nav link is clicked \u2014 verify by clicking a link",
        "Sheet closes on outside click / overlay click \u2014 verify by clicking overlay"
      ],
      "passes": true
    },
    {
      "group": "Layout-Navigation",
      "feature": "Page header component with breadcrumbs",
      "description": "Create web/src/components/layout/page-header.tsx that accepts title (string), description (optional string), and actions (optional ReactNode for action buttons). Create web/src/components/layout/breadcrumbs.tsx that reads the current route path and renders breadcrumb links (e.g., Dashboard > Brews > My IPA). Use these in all page components for consistent headers.",
      "acceptance_criteria": [
        "PageHeader renders title and optional description \u2014 verify by reading source and viewing in browser",
        "PageHeader renders optional action buttons slot on the right \u2014 verify by passing a button as actions prop",
        "Breadcrumbs component renders path segments as clickable links \u2014 verify by navigating to /brews/:id and seeing breadcrumbs",
        "Breadcrumb home link goes to / \u2014 verify by clicking"
      ],
      "passes": true
    },
    {
      "group": "Layout-Navigation",
      "feature": "Toast notification system",
      "description": "Set up the Sonner toast notification system (shadcn/ui's toast solution). Add the Toaster component to the app shell. Create a helper utility web/src/lib/toast.ts that exports success(), error(), and info() functions wrapping Sonner's toast API. Use these in mutation hooks to show success/error feedback on CRUD operations.",
      "acceptance_criteria": [
        "Sonner Toaster component rendered in app shell \u2014 verify by reading app-shell.tsx",
        "toast.success('message') shows a green success toast \u2014 verify by calling from a button click",
        "toast.error('message') shows a red error toast \u2014 verify by triggering an error",
        "Toasts auto-dismiss after 4 seconds \u2014 verify by observing behavior",
        "npm run build succeeds \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Dashboard",
      "feature": "Dashboard summary cards",
      "description": "Create web/src/pages/dashboard.tsx as the main landing page. Display summary cards using shadcn Card components: Active Brews count, Total Hydrometers count, Latest Reading (temperature + gravity from most recent reading across all hydrometers), and Readings Today count. Each card uses TanStack Query hooks to fetch data from the API. Show loading skeletons while data loads.",
      "acceptance_criteria": [
        "Dashboard page renders 4 summary cards in a responsive grid (2x2 on desktop, stacked on mobile) \u2014 verify by viewing in browser",
        "Active Brews card shows count from GET /brews?status=Active \u2014 verify by reading source and checking API call",
        "Total Hydrometers card shows count from GET /hydrometers \u2014 verify by reading source",
        "Latest Reading card shows most recent temperature and gravity \u2014 verify by reading source",
        "Loading skeleton placeholders shown while queries are pending \u2014 verify by throttling network in devtools"
      ],
      "passes": true
    },
    {
      "group": "Dashboard",
      "feature": "Active brews quick-view list",
      "description": "Below the summary cards on the dashboard, render a section titled 'Active Brews' showing a compact list of all brews with status=Active. Each row shows: brew name, hydrometer color (as a colored dot), current gravity (from latest reading), days since start_date, and a link to the brew detail page. If no active brews, show an empty state with a 'Start a Brew' button linking to /brews/new.",
      "acceptance_criteria": [
        "Active brews section renders below summary cards \u2014 verify by viewing in browser",
        "Each brew row shows name, color dot, current gravity, days active \u2014 verify by reading source",
        "Clicking a brew row navigates to /brews/:id \u2014 verify by clicking",
        "Empty state shown with 'Start a Brew' button when no active brews \u2014 verify by testing with empty API response",
        "Color dot matches the hydrometer's TiltColor \u2014 verify by viewing with colored hydrometers"
      ],
      "passes": true
    },
    {
      "group": "Dashboard",
      "feature": "Recent readings mini-chart",
      "description": "Add a Recharts LineChart to the dashboard showing the last 24 hours of gravity readings across all active brews. X-axis is time (formatted with date-fns), Y-axis is specific gravity. Each brew is a separate colored line. Use TanStack Query to fetch readings with since=24h filter. Include a chart legend identifying each brew by name. Show a loading skeleton while data loads.",
      "acceptance_criteria": [
        "Recharts LineChart renders on dashboard \u2014 verify by viewing in browser",
        "X-axis shows time labels formatted as HH:mm \u2014 verify by viewing chart",
        "Y-axis shows specific gravity values (e.g., 1.000\u20131.100) \u2014 verify by viewing chart",
        "Multiple brews render as separate colored lines with legend \u2014 verify by viewing with multiple active brews",
        "Chart fetches readings with since parameter for last 24h \u2014 verify by inspecting network requests"
      ],
      "passes": true
    },
    {
      "group": "Dashboard",
      "feature": "Auto-refresh with configurable interval",
      "description": "Configure the dashboard's TanStack Query hooks with a refetchInterval of 30 seconds so data updates automatically without manual refresh. Add a visual indicator (small pulsing dot or timestamp) showing when data was last refreshed. Add a manual refresh button (RefreshCw icon) that invalidates all dashboard queries immediately.",
      "acceptance_criteria": [
        "Dashboard data auto-refreshes every 30 seconds \u2014 verify by watching network tab for periodic requests",
        "Last refreshed timestamp displayed on dashboard \u2014 verify by viewing in browser",
        "Manual refresh button triggers immediate refetch \u2014 verify by clicking and watching network tab",
        "RefreshCw icon animates (spins) during refetch \u2014 verify by clicking refresh and observing animation"
      ],
      "passes": true
    },
    {
      "group": "Brew-Management",
      "feature": "Brew list page with status filtering",
      "description": "Create web/src/pages/brew-list.tsx displaying all brews in a shadcn Table. Columns: Name, Style, Hydrometer (color dot + name), Status (Badge with color coding: Active=green, Completed=blue, Archived=gray), OG, Current SG, ABV, Start Date. Add a status filter using shadcn Tabs or ToggleGroup (All, Active, Completed, Archived) that passes ?status= query param to the API. Include a 'New Brew' button in the page header linking to /brews/new. Show loading skeleton rows while data loads and an empty state when no brews exist.",
      "acceptance_criteria": [
        "Brew list table renders with all specified columns \u2014 verify by viewing in browser with seed data",
        "Status badges are color-coded (Active=green, Completed=blue, Archived=gray) \u2014 verify by viewing",
        "Status filter tabs filter the brew list via API query param \u2014 verify by clicking each tab and checking network requests",
        "Clicking a brew row navigates to /brews/:id \u2014 verify by clicking",
        "'New Brew' button in header links to /brews/new \u2014 verify by clicking",
        "Empty state shown when no brews match filter \u2014 verify by selecting a filter with no results"
      ],
      "passes": true
    },
    {
      "group": "Brew-Management",
      "feature": "Create brew form page",
      "description": "Create web/src/pages/brew-new.tsx with a form for creating a new brew. Fields: Name (required text input), Style (optional text input), Hydrometer (required select dropdown populated from GET /hydrometers), OG (optional number input), Target FG (optional number input), Notes (optional textarea). Use shadcn form components (Input, Label, Select, Textarea). On submit, POST to /brews and navigate to the new brew's detail page on success. Show validation errors inline and a toast on success/failure.",
      "acceptance_criteria": [
        "Create brew form renders with all specified fields \u2014 verify by viewing in browser",
        "Hydrometer dropdown populated from API \u2014 verify by checking network request for GET /hydrometers",
        "Name field is required \u2014 verify by submitting empty form and seeing validation error",
        "Successful submission POSTs to /brews and redirects to /brews/:id \u2014 verify by filling form and submitting",
        "Success toast shown on creation \u2014 verify by observing toast after submit",
        "Error toast shown on API failure \u2014 verify by testing with server down"
      ],
      "passes": true
    },
    {
      "group": "Brew-Management",
      "feature": "Brew detail page with readings summary",
      "description": "Create web/src/pages/brew-detail.tsx that fetches a single brew by ID (GET /brews/:id) and displays its full details. Show: brew name as page title, status badge, style, OG/FG/Target FG/ABV in a stats grid, hydrometer info, start/end dates formatted with date-fns, and notes. Below the details, show a 'Readings' section (placeholder for now \u2014 will be filled by Readings-Visualization group). Add action buttons in the page header: Edit (opens edit dialog), Complete Brew, Archive Brew, Delete Brew (with confirmation dialog).",
      "acceptance_criteria": [
        "Brew detail page fetches and displays brew data \u2014 verify by navigating to /brews/:id",
        "Stats grid shows OG, FG, Target FG, ABV \u2014 verify by viewing in browser",
        "Status badge matches brew status \u2014 verify by viewing",
        "Dates formatted with date-fns (e.g., 'Feb 14, 2026') \u2014 verify by viewing",
        "Edit button opens edit dialog/form \u2014 verify by clicking",
        "Delete button shows confirmation dialog before deleting \u2014 verify by clicking",
        "Complete/Archive buttons update brew status via API \u2014 verify by clicking and checking status change"
      ],
      "passes": true
    },
    {
      "group": "Brew-Management",
      "feature": "Edit brew dialog with inline updates",
      "description": "Create web/src/components/brew/edit-brew-dialog.tsx as a shadcn Dialog that pre-fills form fields with the current brew data. Fields: Name, Style, OG, FG, Target FG, ABV, Notes, Status (select). On submit, PUT to /brews/:id. Invalidate the brew detail query on success so the page refreshes. Show toast on success/error. Cancel button closes the dialog without changes.",
      "acceptance_criteria": [
        "Edit dialog opens pre-filled with current brew data \u2014 verify by clicking Edit on brew detail page",
        "All editable fields present: Name, Style, OG, FG, Target FG, ABV, Notes, Status \u2014 verify by viewing dialog",
        "Submitting sends PUT /brews/:id with updated fields \u2014 verify by editing and checking network request",
        "Brew detail page refreshes with new data after successful edit \u2014 verify by editing and observing page update",
        "Success toast shown after edit \u2014 verify by observing",
        "Cancel closes dialog without API call \u2014 verify by clicking Cancel and checking no network request"
      ],
      "passes": true
    },
    {
      "group": "Brew-Management",
      "feature": "Delete brew with confirmation",
      "description": "Create web/src/components/brew/delete-brew-dialog.tsx as a shadcn AlertDialog that confirms deletion. Shows brew name and a warning message. On confirm, DELETE /brews/:id, show success toast, and navigate back to /brews. On cancel, close dialog. Use the useMutation hook with onSuccess callback to invalidate queries and redirect.",
      "acceptance_criteria": [
        "Delete confirmation dialog shows brew name and warning \u2014 verify by clicking Delete on brew detail",
        "Confirming sends DELETE /brews/:id \u2014 verify by confirming and checking network request",
        "Success toast and redirect to /brews after deletion \u2014 verify by confirming delete",
        "Cancel closes dialog without API call \u2014 verify by clicking Cancel",
        "Brew list refreshes (query invalidated) after deletion \u2014 verify by checking brew is gone from list"
      ],
      "passes": true
    },
    {
      "group": "Readings-Visualization",
      "feature": "Gravity and temperature line charts on brew detail",
      "description": "Create web/src/components/readings/readings-chart.tsx using Recharts. Render a dual-axis LineChart: left Y-axis for specific gravity (e.g., 1.000\u20131.100), right Y-axis for temperature (\u00b0F), X-axis for time (formatted with date-fns). Gravity line in blue, temperature line in orange. Accept brewId prop and fetch readings via useReadings(brewId). Support time range selection (Last 24h, Last 7d, Last 30d, All) via buttons that adjust the 'since' query param. Include tooltips showing exact values on hover. Responsive \u2014 fills container width.",
      "acceptance_criteria": [
        "Dual-axis LineChart renders gravity (left axis) and temperature (right axis) \u2014 verify by viewing on brew detail page",
        "X-axis shows time labels formatted appropriately for the selected range \u2014 verify by viewing chart",
        "Tooltip on hover shows exact gravity, temperature, and timestamp \u2014 verify by hovering over data points",
        "Time range selector buttons (24h, 7d, 30d, All) filter the displayed data \u2014 verify by clicking each and watching chart update",
        "Chart is responsive and fills container width \u2014 verify by resizing browser"
      ],
      "passes": true
    },
    {
      "group": "Readings-Visualization",
      "feature": "Readings data table with pagination",
      "description": "Create web/src/components/readings/readings-table.tsx showing readings in a shadcn Table below the chart on the brew detail page. Columns: Recorded At (formatted datetime), Temperature (\u00b0F), Gravity (SG), RSSI (if available). Sort by recorded_at DESC by default. Implement client-side pagination (25 rows per page) with Previous/Next buttons. Accept brewId prop and reuse the useReadings hook.",
      "acceptance_criteria": [
        "Readings table renders with Recorded At, Temperature, Gravity, RSSI columns \u2014 verify by viewing on brew detail page",
        "Rows sorted by recorded_at DESC (newest first) \u2014 verify by checking row order",
        "Pagination shows 25 rows per page with Previous/Next controls \u2014 verify by navigating pages",
        "Pagination state resets when brewId changes \u2014 verify by navigating between brews",
        "Empty state shown when no readings exist \u2014 verify with a brew that has no readings"
      ],
      "passes": true
    },
    {
      "group": "Readings-Visualization",
      "feature": "Fermentation progress indicators",
      "description": "Create web/src/components/readings/fermentation-stats.tsx that calculates and displays fermentation metrics from the readings data. Show: Current Gravity (latest reading), Apparent Attenuation (% = (OG - current) / (OG - 1.0) * 100), Estimated ABV ((OG - current) * 131.25), Temperature Trend (arrow up/down/steady based on last 3 readings), Time Since Last Reading (formatted with date-fns formatDistanceToNow). Display as a row of stat cards above the chart on the brew detail page.",
      "acceptance_criteria": [
        "Fermentation stats render as a row of cards above the chart \u2014 verify by viewing brew detail page",
        "Current Gravity shows the latest reading's gravity value \u2014 verify by checking against API data",
        "Apparent Attenuation calculated correctly from OG and current gravity \u2014 verify with known values",
        "Estimated ABV calculated correctly \u2014 verify with known values (e.g., OG 1.050, FG 1.010 = ~5.25%)",
        "Temperature Trend shows up/down/steady arrow \u2014 verify by checking with readings that have varying temperatures",
        "Time Since Last Reading shows human-readable duration (e.g., '5 minutes ago') \u2014 verify by viewing"
      ],
      "passes": true
    },
    {
      "group": "Readings-Visualization",
      "feature": "Gravity target line and completion detection",
      "description": "Enhance the readings chart to display the brew's Target FG as a horizontal dashed reference line (green) when set. When the current gravity reaches or goes below the Target FG, show a visual alert banner on the brew detail page: 'Target gravity reached! Consider completing this brew.' with a 'Complete Brew' action button that sets the brew status to Completed via PUT /brews/:id.",
      "acceptance_criteria": [
        "Target FG dashed line renders on chart when brew has targetFg set \u2014 verify by viewing chart for a brew with targetFg",
        "Target FG line does not render when targetFg is null \u2014 verify with a brew without targetFg",
        "Alert banner appears when latest gravity <= targetFg \u2014 verify by checking with appropriate data",
        "Alert banner 'Complete Brew' button sends PUT to update status \u2014 verify by clicking and checking network",
        "Alert banner hidden when gravity is above targetFg \u2014 verify with appropriate data"
      ],
      "passes": true
    },
    {
      "group": "Hydrometer-Management",
      "feature": "Hydrometer list page with status indicators",
      "description": "Create web/src/pages/hydrometer-list.tsx displaying all registered hydrometers in a responsive card grid (not a table \u2014 cards work better for the small number of hydrometers). Each card shows: color name with a large colored circle matching the Tilt color, optional alias name, calibration offsets (temp_offset_f, gravity_offset), registration date formatted with date-fns, and whether it's currently assigned to an active brew (with brew name link). Add a 'Register Hydrometer' button in the page header. Use the useHydrometers() hook.",
      "acceptance_criteria": [
        "Hydrometer cards render in a responsive grid (3 columns desktop, 2 tablet, 1 mobile) \u2014 verify by viewing and resizing browser",
        "Each card shows colored circle matching TiltColor (Red=#FF0000, Green=#00FF00, etc.) \u2014 verify by viewing",
        "Active brew assignment shown on card with link to brew detail \u2014 verify by clicking brew link",
        "'Register Hydrometer' button in page header \u2014 verify by viewing",
        "Empty state shown when no hydrometers registered \u2014 verify with empty API response"
      ],
      "passes": true
    },
    {
      "group": "Hydrometer-Management",
      "feature": "Register hydrometer dialog",
      "description": "Create web/src/components/hydrometer/register-hydrometer-dialog.tsx as a shadcn Dialog with a form. Fields: Color (required Select dropdown with all 8 TiltColor options, each with a colored dot preview), Name/Alias (optional text input). On submit, POST to /hydrometers. Show success toast and invalidate the hydrometer list query. Only show colors that aren't already registered (fetch existing and filter).",
      "acceptance_criteria": [
        "Register dialog opens from 'Register Hydrometer' button \u2014 verify by clicking button",
        "Color select shows all 8 TiltColor options with colored dot previews \u2014 verify by opening select",
        "Already-registered colors are filtered out or disabled \u2014 verify by registering one color and checking it's unavailable",
        "Successful registration shows toast and new card appears in list \u2014 verify by submitting form",
        "Name/alias field is optional \u2014 verify by submitting with only color selected"
      ],
      "passes": true
    },
    {
      "group": "Hydrometer-Management",
      "feature": "Edit hydrometer dialog with calibration offsets",
      "description": "Create web/src/components/hydrometer/edit-hydrometer-dialog.tsx as a shadcn Dialog for editing hydrometer settings. Fields: Name/Alias (text input), Temperature Offset \u00b0F (number input with step 0.1, help text explaining this adjusts raw temperature readings), Gravity Offset (number input with step 0.001, help text explaining this adjusts raw gravity readings). On submit, PUT to /hydrometers/:id. Show toast on success and invalidate queries.",
      "acceptance_criteria": [
        "Edit dialog opens pre-filled with current hydrometer data \u2014 verify by clicking edit on a hydrometer card",
        "Temperature Offset input accepts decimal values with step 0.1 \u2014 verify by entering 0.5",
        "Gravity Offset input accepts decimal values with step 0.001 \u2014 verify by entering 0.002",
        "Help text explains what each offset does \u2014 verify by reading form labels",
        "Successful edit updates the card and shows toast \u2014 verify by editing and observing"
      ],
      "passes": true
    },
    {
      "group": "Hydrometer-Management",
      "feature": "Delete hydrometer with safety check",
      "description": "Add a delete button to each hydrometer card that opens a shadcn AlertDialog. If the hydrometer is assigned to an active brew, show a warning: 'This hydrometer is assigned to an active brew. Deleting it will unlink it.' On confirm, DELETE /hydrometers/:id, show toast, and invalidate queries. Disable delete for hydrometers with active brews unless user confirms the warning.",
      "acceptance_criteria": [
        "Delete button visible on each hydrometer card \u2014 verify by viewing",
        "Confirmation dialog shows hydrometer color and name \u2014 verify by clicking delete",
        "Warning shown when hydrometer has active brew \u2014 verify with an assigned hydrometer",
        "Successful deletion removes card and shows toast \u2014 verify by confirming delete",
        "Cancel closes dialog without API call \u2014 verify by clicking cancel"
      ],
      "passes": true
    },
    {
      "group": "Hydrometer-Management",
      "feature": "Tilt color utility with hex color mapping",
      "description": "Create web/src/lib/tilt-colors.ts that exports a mapping from TiltColor string to: hex color code, display name, and a lighter background variant for cards. Colors: Red=#E03131, Green=#2F9E44, Black=#495057, Purple=#7048E8, Orange=#E8590C, Blue=#1971C2, Yellow=#F08C00, Pink=#D6336C. Export a ColorDot component (web/src/components/ui/color-dot.tsx) that renders a small circle with the correct color. Use this everywhere hydrometers are displayed.",
      "acceptance_criteria": [
        "web/src/lib/tilt-colors.ts exports TILT_COLOR_MAP with hex, displayName, bgLight for all 8 colors \u2014 verify by reading file",
        "ColorDot component renders a circle with correct color for each TiltColor \u2014 verify by viewing all 8 colors",
        "ColorDot used in hydrometer cards, brew list, and dashboard \u2014 verify by searching source for ColorDot usage",
        "npm run build succeeds with no type errors \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Client-Simulate",
      "feature": "Add --simulate CLI flag and simulator configuration args",
      "description": "Add a `--simulate` boolean flag to the clap Args struct in client/src/main.rs. When set, the client skips BLE scanner initialization and uses a simulator instead. Add supporting args: `--sim-colors` (comma-separated list of TiltColor names to simulate, default 'Red'), `--sim-og` (starting OG, default 1.055), `--sim-target-fg` (target FG, default 1.012), `--sim-temp` (base temperature \u00b0F, default 68.0). These args are only used when --simulate is set. Log a clear info message when starting in simulate mode vs BLE mode.",
      "acceptance_criteria": [
        "cargo build -p client succeeds with new CLI args \u2014 verify by running command",
        "--simulate flag accepted without error \u2014 verify with cargo run -p client -- --simulate --server-url http://localhost:8000",
        "--sim-colors, --sim-og, --sim-target-fg, --sim-temp args parsed correctly \u2014 verify by adding trace log and checking output",
        "Without --simulate, client still attempts BLE scanner initialization \u2014 verify by running without flag"
      ],
      "passes": true
    },
    {
      "group": "Client-Simulate",
      "feature": "Create simulator module with fermentation curve generation",
      "description": "Create client/src/simulator.rs with a TiltSimulator struct. It accepts: colors (Vec<TiltColor>), starting OG, target FG, base temperature, and scan interval. On each call to generate_readings(), it produces one TiltReading per configured color. Gravity follows an exponential decay curve from OG toward target FG over ~14 days (configurable). Temperature has small random jitter (\u00b10.5\u00b0F). Gravity has tiny noise (\u00b10.001). The simulator tracks elapsed time from first call to compute position on the fermentation curve. RSSI is simulated as a random value between -60 and -80.",
      "acceptance_criteria": [
        "cargo build -p client succeeds \u2014 verify by running command",
        "TiltSimulator::new() constructs without panic \u2014 verify via unit test",
        "generate_readings() returns one reading per configured color \u2014 verify via unit test",
        "Gravity decreases over successive calls following exponential decay \u2014 verify via unit test calling generate_readings() multiple times",
        "Temperature values stay within base_temp \u00b1 1.0\u00b0F \u2014 verify via unit test",
        "RSSI values are in range -80..=-60 \u2014 verify via unit test"
      ],
      "passes": true
    },
    {
      "group": "Client-Simulate",
      "feature": "Wire simulator into main loop as alternative to BLE scanner",
      "description": "Refactor client/src/main.rs to branch on the --simulate flag. When --simulate is set: skip TiltScanner::new(), construct a TiltSimulator from the CLI args, and in the main loop call simulator.generate_readings() instead of scanner.scan_once(). The rest of the loop (buffering, uploading, backoff) remains identical. Parse --sim-colors by splitting on comma and mapping each to TiltColor::parse(). Log each simulated reading at debug level.",
      "acceptance_criteria": [
        "cargo build -p client succeeds \u2014 verify by running command",
        "Running with --simulate generates readings and uploads them to the server \u2014 verify by running with a live server and checking readings appear",
        "Running without --simulate still uses BLE scanner \u2014 verify by running without flag on a machine with BLE",
        "Invalid --sim-colors value produces a clear error message \u2014 verify by passing an invalid color name"
      ],
      "passes": true
    },
    {
      "group": "Client-Simulate",
      "feature": "Unit tests for simulator module",
      "description": "Add comprehensive #[cfg(test)] tests in client/src/simulator.rs. Tests: (1) default config produces readings, (2) multi-color simulation produces correct number of readings, (3) gravity stays within OG..target_fg bounds, (4) gravity decreases monotonically when noise is removed (or on average over many samples), (5) temperature jitter stays within bounds, (6) RSSI is always in valid range, (7) fermentation curve reaches near target_fg after simulated 14 days. Use deterministic time advancement where possible.",
      "acceptance_criteria": [
        "cargo test -p client passes all new tests \u2014 verify by running command",
        "At least 5 test functions exist in simulator module \u2014 verify by counting #[test] annotations",
        "Tests cover gravity bounds, temperature jitter, RSSI range, and multi-color output \u2014 verify by reading test names",
        "No existing tests broken \u2014 verify by running cargo test --workspace"
      ],
      "passes": true
    },
    {
      "group": "Justfile",
      "feature": "Create justfile with database and Docker infrastructure recipes",
      "description": "Create a justfile at the project root with recipes for database and Docker infrastructure management. Recipes: `db-up` (docker compose up -d db, wait for healthy), `db-down` (docker compose down), `db-reset` (down + up + migrate), `db-migrate` (sea-orm-cli migrate up with DATABASE_URL from .env), `db-entities` (sea-orm-cli generate entity with correct output path and --with-serde both). Use dotenv-load to auto-load .env. Add a default recipe that lists all available recipes. Verify with `just --list`.",
      "acceptance_criteria": [
        "justfile exists at project root \u2014 verify by reading file",
        "`just --list` displays all recipes without error \u2014 verify by running command",
        "`just db-up` starts the Postgres container \u2014 verify by running command",
        "`just db-down` stops containers \u2014 verify by running command",
        "Recipes use dotenv-load for DATABASE_URL \u2014 verify by reading justfile"
      ],
      "passes": true
    },
    {
      "group": "Justfile",
      "feature": "Add dev workflow recipes to justfile",
      "description": "Add development workflow recipes to the justfile: `server` (cargo run -p server), `client-sim` (cargo run -p client -- --simulate with sensible defaults for server-url, scan-interval, sim-colors), `web` (npm run dev in web/), `dev` (run db-up then server, client-sim, and web concurrently \u2014 or document that user should run in separate terminals). Add `build` recipe that builds all Rust crates and the web frontend. Add `clean` recipe (cargo clean + rm -rf web/dist).",
      "acceptance_criteria": [
        "`just --list` shows server, client-sim, web, dev, build, clean recipes \u2014 verify by running command",
        "`just build` compiles Rust workspace and web frontend without error \u2014 verify by running command",
        "`just client-sim` starts client in simulate mode \u2014 verify by running and checking log output",
        "`just clean` removes build artifacts \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Justfile",
      "feature": "Add test and code quality recipes to justfile",
      "description": "Add test and code quality recipes to the justfile: `test` (cargo test --workspace + npm run build in web/), `test-rust` (cargo test --workspace), `test-web` (npm run build in web/), `fmt` (cargo fmt --all), `fmt-check` (cargo fmt --all -- --check), `lint` (cargo clippy --workspace -- -D warnings), `check` (cargo check --workspace). Add a `ci` recipe that runs fmt-check, lint, test (the full pipeline). Verify all recipes work.",
      "acceptance_criteria": [
        "`just test` runs all Rust tests and web build \u2014 verify by running command",
        "`just fmt` formats code without error \u2014 verify by running command",
        "`just lint` runs clippy without error (or shows real warnings) \u2014 verify by running command",
        "`just ci` runs the full quality pipeline \u2014 verify by running command",
        "`just --list` shows all test/quality recipes \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "OAuth2-Auth",
      "feature": "Add Authentik OAuth2 OIDC Rocket fairing and session management",
      "description": "Integrate OAuth2/OIDC authentication into the Rocket server using the `openidconnect` crate. Add a fairing that discovers the Authentik OIDC provider metadata from AUTHENTIK_ISSUER_URL env var. Store AUTHENTIK_CLIENT_ID, AUTHENTIK_CLIENT_SECRET, AUTHENTIK_ISSUER_URL, and SESSION_SECRET in .env. Use Rocket's private cookies (encrypted with ROCKET_SECRET_KEY) to store the session token after successful login. Create a `CurrentUser` request guard that reads the session cookie, validates the OIDC ID token, and extracts user claims (sub, email, name, groups). Return 401 JSON if the guard fails on API routes.",
      "acceptance_criteria": [
        "cargo add openidconnect --features reqwest,ring to server crate \u2014 verify with cargo check -p server",
        "AUTHENTIK_ISSUER_URL, AUTHENTIK_CLIENT_ID, AUTHENTIK_CLIENT_SECRET env vars documented in .env.example \u2014 verify by reading file",
        "CurrentUser request guard compiles and extracts sub/email from valid session cookie \u2014 verify with unit test using mock claims",
        "API routes protected by CurrentUser return 401 JSON {\"error\":\"Unauthorized\"} when no session \u2014 verify with curl against running server",
        "OIDC provider metadata fetched at startup from Authentik discovery endpoint \u2014 verify by checking server startup logs"
      ],
      "passes": true
    },
    {
      "group": "OAuth2-Auth",
      "feature": "Implement OAuth2 login and callback routes",
      "description": "Create GET /api/v1/auth/login route that generates an OAuth2 authorization URL (with PKCE code_challenge, state, nonce) and redirects the browser to Authentik. Create GET /api/v1/auth/callback route that receives the authorization code, exchanges it for tokens via Authentik's token endpoint, validates the ID token (signature, nonce, expiry), extracts user claims, and sets an encrypted session cookie. On success redirect to the frontend SPA root (/). On failure return a redirect to /?error=auth_failed. Store PKCE verifier and state in a short-lived cookie during the flow.",
      "acceptance_criteria": [
        "GET /api/v1/auth/login redirects to Authentik authorization URL with correct client_id, redirect_uri, scope=openid+email+profile, PKCE params \u2014 verify by visiting URL in browser",
        "GET /api/v1/auth/callback exchanges code for tokens and sets encrypted session cookie \u2014 verify by completing OAuth2 flow in browser",
        "Invalid state or nonce in callback returns redirect to /?error=auth_failed \u2014 verify by tampering with state param",
        "Successful login redirects to / and subsequent API requests include valid session \u2014 verify by completing login flow end-to-end",
        "PKCE code_verifier stored in short-lived cookie and validated in callback \u2014 verify by reading route source"
      ],
      "passes": true
    },
    {
      "group": "OAuth2-Auth",
      "feature": "Implement logout route and session invalidation",
      "description": "Create POST /api/v1/auth/logout route (protected by CurrentUser guard) that clears the session cookie and redirects to Authentik's end_session_endpoint to perform RP-initiated logout. Create GET /api/v1/auth/me route that returns the current user's claims (sub, email, name) as JSON for the frontend to use. Add the logout URL to the OIDC discovery document or hardcode from AUTHENTIK_ISSUER_URL.",
      "acceptance_criteria": [
        "POST /api/v1/auth/logout clears session cookie \u2014 verify by checking Set-Cookie header with Max-Age=0",
        "POST /api/v1/auth/logout redirects to Authentik end_session_endpoint \u2014 verify by following redirect in browser",
        "GET /api/v1/auth/me returns {sub, email, name} JSON for authenticated user \u2014 verify with curl using valid session",
        "GET /api/v1/auth/me returns 401 for unauthenticated requests \u2014 verify with curl without session cookie",
        "cargo test -p server passes all auth route tests \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "OAuth2-Auth",
      "feature": "Protect all existing API routes with CurrentUser guard",
      "description": "Apply the CurrentUser request guard to all existing route handlers in server/src/routes/ (brews.rs, hydrometers.rs, readings.rs). The readings POST endpoint is an exception \u2014 it accepts either a valid session OR a valid API key (handled in the API-Keys group). Update Rocket catchers to return consistent JSON error shapes for 401 and 403. Update the CORS fairing to allow credentials (allow_credentials: true) and restrict allowed origins to the configured FRONTEND_URL env var instead of wildcard.",
      "acceptance_criteria": [
        "GET /api/v1/brews returns 401 without session cookie \u2014 verify with curl",
        "GET /api/v1/hydrometers returns 401 without session cookie \u2014 verify with curl",
        "CORS fairing allows credentials and restricts origin to FRONTEND_URL \u2014 verify by reading fairing config and checking CORS headers",
        "cargo test -p server passes \u2014 verify by running command",
        "Existing integration tests updated to include mock CurrentUser guard \u2014 verify by reading test files"
      ],
      "passes": true
    },
    {
      "group": "API-Keys",
      "feature": "API key database schema and migration",
      "description": "Generate a new SeaORM migration for the api_keys table: id (UUID PK), name (VARCHAR, user-provided label), key_hash (VARCHAR, bcrypt/SHA-256 hash of the raw key), prefix (VARCHAR 8 chars, first 8 chars of raw key for display), created_by (VARCHAR, user sub from OIDC), last_used_at (TIMESTAMPTZ nullable), expires_at (TIMESTAMPTZ nullable), created_at (TIMESTAMPTZ). Run `sea-orm-cli migrate generate create_api_keys` and implement the Up/Down. Then regenerate entities with `sea-orm-cli generate entity`. Add a unique index on key_hash.",
      "acceptance_criteria": [
        "sea-orm-cli migrate up applies the api_keys migration without error \u2014 verify by running command against dev DB",
        "api_keys table has all specified columns \u2014 verify with \\d api_keys in psql",
        "Unique index on key_hash exists \u2014 verify with \\di in psql",
        "SeaORM entity file server/src/models/entities/api_keys.rs generated \u2014 verify with ls",
        "sea-orm-cli migrate down rolls back cleanly \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "API-Keys",
      "feature": "API key generation and management service",
      "description": "Create server/src/services/api_keys.rs with functions: generate_api_key() -> (raw: String, hash: String, prefix: String) that generates a cryptographically random 32-byte key encoded as hex (64 chars), computes SHA-256 hash for storage, and extracts the first 8 chars as prefix. create_api_key(db, name, created_by, expires_at) -> ApiKeyResponse that inserts into DB and returns the raw key ONCE (never stored). list_api_keys(db, user_sub) -> Vec<ApiKeySummary> returning id, name, prefix, last_used_at, expires_at, created_at (never the hash). delete_api_key(db, id, user_sub) -> Result that verifies ownership before deletion. validate_api_key(db, raw_key) -> Option<ApiKeyRecord> that hashes the input and looks up by hash, updating last_used_at.",
      "acceptance_criteria": [
        "generate_api_key() returns a 64-char hex string, its SHA-256 hash, and 8-char prefix \u2014 verify with unit test",
        "create_api_key() inserts record and returns raw key \u2014 verify with SeaORM mock test",
        "list_api_keys() never returns key_hash field \u2014 verify by reading ApiKeySummary struct definition",
        "validate_api_key() updates last_used_at on successful validation \u2014 verify with integration test",
        "delete_api_key() returns error if user_sub doesn't match created_by \u2014 verify with unit test",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "API-Keys",
      "feature": "API key CRUD routes",
      "description": "Create server/src/routes/api_keys.rs with routes mounted at /api/v1/api-keys: GET / (list user's keys, requires CurrentUser), POST / (create key, requires CurrentUser, body: {name, expires_at?}, returns {id, name, prefix, key, created_at} \u2014 key shown only once), DELETE /<id> (delete key, requires CurrentUser, verifies ownership). Mount these routes in main.rs. The raw key in the POST response must be clearly marked in the response as 'Store this key securely \u2014 it will not be shown again.'",
      "acceptance_criteria": [
        "GET /api/v1/api-keys returns list of user's keys without key_hash \u2014 verify with curl using valid session",
        "POST /api/v1/api-keys returns {id, name, prefix, key, message} with raw key \u2014 verify with curl",
        "DELETE /api/v1/api-keys/:id returns 204 on success \u2014 verify with curl",
        "DELETE /api/v1/api-keys/:id returns 403 if key belongs to another user \u2014 verify with curl",
        "All routes return 401 without valid session \u2014 verify with curl",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "API-Keys",
      "feature": "API key authentication guard for readings endpoint",
      "description": "Create an ApiKeyGuard Rocket request guard that reads the Authorization header (Bearer <key> format) or X-API-Key header, calls validate_api_key() to look up and validate the key, and returns the associated created_by user sub. Create a combined AuthContext enum (Session(CurrentUser) | ApiKey(String)) that the readings POST route accepts \u2014 allowing either a valid session cookie OR a valid API key header. All other routes continue to require CurrentUser session only.",
      "acceptance_criteria": [
        "POST /api/v1/readings accepts requests with valid X-API-Key header \u2014 verify with curl using a generated key",
        "POST /api/v1/readings accepts requests with valid Bearer token in Authorization header \u2014 verify with curl",
        "POST /api/v1/readings returns 401 with neither session nor API key \u2014 verify with curl",
        "POST /api/v1/readings returns 401 with invalid/expired API key \u2014 verify with curl using wrong key",
        "last_used_at updated in DB when API key used \u2014 verify by checking DB after request",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "API-Keys",
      "feature": "Update client to send API key with readings",
      "description": "Add --api-key CLI argument to client/src/main.rs (optional string). Update client/src/uploader.rs to include the API key in the X-API-Key request header when provided. If --api-key is not set, the client sends requests without authentication (for backward compatibility during development). Update the tilt-client.service ExecStart to include --api-key via an EnvironmentFile or direct arg. Document the API key setup in the service file comments.",
      "acceptance_criteria": [
        "--api-key arg accepted by client binary \u2014 verify with cargo run -p client -- --help",
        "Uploader includes X-API-Key header when api_key is Some \u2014 verify by reading uploader.rs",
        "Uploader sends no auth header when api_key is None \u2014 verify by reading uploader.rs",
        "tilt-client.service updated with --api-key placeholder \u2014 verify by reading service file",
        "cargo build -p client succeeds \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Server-Security",
      "feature": "Rate limiting fairing for auth and API endpoints",
      "description": "Add rate limiting to the Rocket server using an in-memory token bucket (or leaky bucket) implemented with a DashMap<IpAddr, RateLimitState> stored in Rocket managed state. Apply limits: /api/v1/auth/* endpoints: 10 requests/minute per IP. /api/v1/readings POST: 60 requests/minute per API key. All other API endpoints: 120 requests/minute per IP. Return HTTP 429 with JSON {\"error\": \"Too Many Requests\", \"retry_after\": N} and Retry-After header when limit exceeded. Implement as a Rocket fairing.",
      "acceptance_criteria": [
        "Rate limit fairing attached in main.rs \u2014 verify by reading main.rs",
        "Sending >10 requests/min to /api/v1/auth/login returns 429 with Retry-After header \u2014 verify with a loop curl command",
        "429 response body is JSON {\"error\": \"Too Many Requests\", \"retry_after\": N} \u2014 verify by reading response body",
        "Rate limit state resets after the window expires \u2014 verify by waiting and retrying",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Server-Security",
      "feature": "Security headers fairing",
      "description": "Add a Rocket fairing that sets security headers on all responses: Strict-Transport-Security: max-age=31536000; includeSubDomains (HSTS), X-Content-Type-Options: nosniff, X-Frame-Options: DENY, Referrer-Policy: strict-origin-when-cross-origin, Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' <AUTHENTIK_ISSUER_URL>. The CSP connect-src should include the configured Authentik issuer URL from env. Remove the X-Powered-By header if present.",
      "acceptance_criteria": [
        "Security headers fairing attached in main.rs \u2014 verify by reading main.rs",
        "curl -I against running server shows Strict-Transport-Security header \u2014 verify by running command",
        "curl -I shows X-Content-Type-Options: nosniff \u2014 verify by running command",
        "curl -I shows X-Frame-Options: DENY \u2014 verify by running command",
        "Content-Security-Policy header present and includes 'self' \u2014 verify by running command",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Server-Security",
      "feature": "CORS lockdown to configured frontend origin",
      "description": "Update the rocket_cors configuration to only allow the origin specified in FRONTEND_URL env var (e.g., https://tilt.schenkenberger.dev). Remove any wildcard (*) origin allowance. Set allow_credentials: true so session cookies work cross-origin. Allowed methods: GET, POST, PUT, DELETE, OPTIONS. Allowed headers: Content-Type, Authorization, X-API-Key. Add FRONTEND_URL to .env.example with a sensible default of http://localhost:5173 for development.",
      "acceptance_criteria": [
        "CORS fairing rejects requests from origins not matching FRONTEND_URL \u2014 verify by sending request with Origin: https://evil.com and checking no CORS headers returned",
        "CORS fairing allows requests from FRONTEND_URL \u2014 verify by sending request with correct Origin",
        "Access-Control-Allow-Credentials: true in CORS response \u2014 verify with curl",
        "X-API-Key listed in Access-Control-Allow-Headers \u2014 verify with curl OPTIONS request",
        "FRONTEND_URL in .env.example \u2014 verify by reading file"
      ],
      "passes": false
    },
    {
      "group": "Server-Security",
      "feature": "Request logging and audit trail",
      "description": "Add a Rocket fairing that logs all API requests with structured tracing fields: method, path, status_code, duration_ms, user_sub (from session if present), api_key_prefix (from API key if present), ip_address, user_agent. Use tracing::info! for 2xx/3xx, tracing::warn! for 4xx, tracing::error! for 5xx. This creates an audit trail for security review. Ensure no sensitive data (passwords, raw API keys, session tokens) appears in logs.",
      "acceptance_criteria": [
        "Request logging fairing attached in main.rs \u2014 verify by reading main.rs",
        "Each request produces a structured log line with method, path, status, duration_ms \u2014 verify by making a request and checking logs",
        "Authenticated requests include user_sub or api_key_prefix in log \u2014 verify by making authenticated request and checking logs",
        "Raw API keys and session tokens do NOT appear in logs \u2014 verify by reading fairing source",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Database-Auth",
      "feature": "User sessions table and session management service",
      "description": "Generate a SeaORM migration for a user_sessions table: id (UUID PK), user_sub (VARCHAR, OIDC subject), email (VARCHAR), name (VARCHAR), id_token_hash (VARCHAR, SHA-256 of the OIDC ID token for revocation), created_at (TIMESTAMPTZ), expires_at (TIMESTAMPTZ), last_seen_at (TIMESTAMPTZ). Run `sea-orm-cli migrate generate create_user_sessions` and implement Up/Down. Regenerate entities. Create server/src/services/sessions.rs with: create_session(), get_session_by_id(), touch_session() (updates last_seen_at), delete_session(), delete_expired_sessions(). Store session ID in the encrypted Rocket cookie instead of the raw ID token.",
      "acceptance_criteria": [
        "sea-orm-cli migrate up applies user_sessions migration \u2014 verify by running command",
        "user_sessions table has all specified columns \u2014 verify with \\d user_sessions in psql",
        "SeaORM entity server/src/models/entities/user_sessions.rs generated \u2014 verify with ls",
        "create_session() inserts and returns session record \u2014 verify with SeaORM mock test",
        "delete_expired_sessions() removes sessions past expires_at \u2014 verify with unit test using past timestamp",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": true
    },
    {
      "group": "Database-Auth",
      "feature": "Session cleanup background task",
      "description": "Add a background tokio task that runs every hour to call delete_expired_sessions() and prune stale sessions from the database. Spawn this task in server/src/main.rs after the DB pool is initialized, using tokio::spawn with a loop and tokio::time::sleep(Duration::from_secs(3600)). Log the number of deleted sessions at info level. This prevents unbounded growth of the sessions table.",
      "acceptance_criteria": [
        "Background cleanup task spawned in main.rs \u2014 verify by reading main.rs",
        "Task calls delete_expired_sessions() every hour \u2014 verify by reading task source",
        "Number of deleted sessions logged at info level \u2014 verify by reading task source",
        "Task does not panic if DB is temporarily unavailable (uses error logging, not unwrap) \u2014 verify by reading source",
        "cargo build -p server succeeds \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Database-Auth",
      "feature": "API key expiry enforcement and last_used_at tracking",
      "description": "Update validate_api_key() in the API keys service to reject keys where expires_at is not null and expires_at < now(). Return a distinct error variant (Expired vs Invalid) so the guard can return an appropriate 401 message. Update the ApiKeyGuard to return {\"error\": \"API key expired\"} vs {\"error\": \"Invalid API key\"} accordingly. Add a DB index on expires_at for efficient expiry queries. Add a background task (similar to session cleanup) that logs a warning for keys expiring within 7 days.",
      "acceptance_criteria": [
        "validate_api_key() returns Err(ApiKeyError::Expired) for expired keys \u2014 verify with unit test using past expires_at",
        "ApiKeyGuard returns {\"error\": \"API key expired\"} with 401 for expired keys \u2014 verify with curl using expired key",
        "ApiKeyGuard returns {\"error\": \"Invalid API key\"} with 401 for wrong key \u2014 verify with curl using wrong key",
        "DB index on api_keys.expires_at exists \u2014 verify with \\di in psql",
        "cargo test -p server passes \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Frontend-Auth",
      "feature": "Auth context provider and useAuth hook",
      "description": "Create web/src/lib/auth.tsx with an AuthContext and AuthProvider component. On mount, call GET /api/v1/auth/me to check if the user is authenticated. Store {user: {sub, email, name} | null, isLoading: boolean} in context. Export a useAuth() hook that returns this context. If the /me call returns 401, set user to null. If it returns the user object, set user. Add the AuthProvider to main.tsx wrapping the router. This is the single source of truth for auth state in the frontend.",
      "acceptance_criteria": [
        "AuthProvider wraps the app in main.tsx \u2014 verify by reading main.tsx",
        "useAuth() returns {user, isLoading} \u2014 verify by reading auth.tsx",
        "On mount, GET /api/v1/auth/me called to hydrate auth state \u2014 verify by inspecting network tab on page load",
        "user is null when /me returns 401 \u2014 verify by testing with logged-out session",
        "user has {sub, email, name} when /me returns 200 \u2014 verify by testing with logged-in session",
        "npm run build succeeds \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Frontend-Auth",
      "feature": "Protected route wrapper and login redirect",
      "description": "Create web/src/components/auth/protected-route.tsx that wraps routes requiring authentication. It uses useAuth() to check auth state. While isLoading is true, show a full-page loading spinner. If user is null (unauthenticated), redirect to GET /api/v1/auth/login (the server-side OAuth2 initiation route) by setting window.location.href. If user is set, render the child route via Outlet. Apply ProtectedRoute to all routes except a public /login-callback placeholder. This ensures the entire app is gated behind Authentik login.",
      "acceptance_criteria": [
        "ProtectedRoute component exists in web/src/components/auth/ \u2014 verify with ls",
        "Unauthenticated users redirected to /api/v1/auth/login \u2014 verify by visiting app without session",
        "Loading spinner shown while auth state is being checked \u2014 verify by throttling network and observing",
        "Authenticated users see the app normally \u2014 verify by logging in and navigating",
        "All app routes wrapped with ProtectedRoute in router config \u2014 verify by reading router config",
        "npm run build succeeds \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Frontend-Auth",
      "feature": "User menu in sidebar with logout",
      "description": "Add a user menu to the bottom of the sidebar in web/src/components/layout/app-shell.tsx. Use useAuth() to get the current user. Display the user's name and email in a shadcn DropdownMenu triggered by clicking the user's avatar (initials in a Circle, using shadcn Avatar). Menu items: 'Signed in as <email>' (disabled, informational), separator, 'API Keys' (links to /settings/api-keys), 'Sign Out' (calls POST /api/v1/auth/logout then reloads page). Show a skeleton while auth is loading.",
      "acceptance_criteria": [
        "User avatar with initials shown at bottom of sidebar \u2014 verify by viewing app while logged in",
        "Clicking avatar opens dropdown with email and menu items \u2014 verify by clicking",
        "'Sign Out' menu item calls POST /api/v1/auth/logout \u2014 verify by clicking and checking network request",
        "After logout, page reloads and user is redirected to Authentik login \u2014 verify by clicking Sign Out",
        "'API Keys' menu item navigates to /settings/api-keys \u2014 verify by clicking",
        "npm run build succeeds \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Frontend-Auth",
      "feature": "API keys management page",
      "description": "Create web/src/pages/settings/api-keys.tsx at route /settings/api-keys. Display a table of the user's API keys with columns: Name, Prefix (first 8 chars, e.g. 'ab12cd34...'), Created, Last Used, Expires, Actions (Delete button). Add a 'Create API Key' button that opens a dialog (web/src/components/settings/create-api-key-dialog.tsx) with a Name field and optional Expires At date picker. On creation, show a one-time display dialog with the full raw key and a copy-to-clipboard button, with a warning 'This key will not be shown again.' Add delete confirmation. Create useApiKeys() TanStack Query hook in web/src/hooks/use-api-keys.ts.",
      "acceptance_criteria": [
        "API keys page renders at /settings/api-keys \u2014 verify by navigating to route",
        "Table shows Name, Prefix, Created, Last Used, Expires columns \u2014 verify by viewing with existing keys",
        "Create dialog has Name field and optional Expires At date picker \u2014 verify by opening dialog",
        "After creation, raw key shown in one-time dialog with copy button \u2014 verify by creating a key",
        "Copy button copies key to clipboard \u2014 verify by clicking and pasting",
        "Delete button shows confirmation before deleting \u2014 verify by clicking delete",
        "npm run build succeeds \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Frontend-Auth",
      "feature": "Add /settings/api-keys route to router and sidebar",
      "description": "Add the /settings route group to the React Router config with /settings/api-keys as a child route rendering the ApiKeysPage. Add a 'Settings' section to the sidebar navigation with a 'API Keys' link (Key icon from Lucide) below the main nav links. Add a separator between the main nav and settings nav. Update the breadcrumbs component to handle /settings/api-keys showing 'Settings > API Keys'. Ensure the route is wrapped in ProtectedRoute.",
      "acceptance_criteria": [
        "/settings/api-keys route renders ApiKeysPage \u2014 verify by navigating to URL",
        "Sidebar shows 'API Keys' link under a Settings section \u2014 verify by viewing sidebar",
        "Breadcrumbs show 'Settings > API Keys' on the page \u2014 verify by viewing page header",
        "Route is protected (redirects to login if unauthenticated) \u2014 verify by visiting without session",
        "npm run build succeeds \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Testing-Security",
      "feature": "Integration tests for OAuth2 auth routes",
      "description": "Add integration tests in server/src/routes/api_keys.rs and a new server/tests/auth_tests.rs using Rocket's local::asynchronous::Client. Tests: (1) GET /api/v1/auth/me returns 401 without session, (2) GET /api/v1/auth/me returns user JSON with mock session cookie, (3) POST /api/v1/auth/logout clears session cookie, (4) GET /api/v1/brews returns 401 without session, (5) GET /api/v1/brews returns 200 with valid mock session. Use a test helper that injects a pre-built encrypted session cookie bypassing the full OAuth2 flow. Mock the OIDC provider using a test issuer URL.",
      "acceptance_criteria": [
        "server/tests/auth_tests.rs exists with at least 5 test functions \u2014 verify with ls and count #[tokio::test] annotations",
        "cargo test -p server auth_tests passes \u2014 verify by running command",
        "Test for 401 on protected route without session passes \u2014 verify by running specific test",
        "Test for 200 on protected route with mock session passes \u2014 verify by running specific test",
        "Test helper for injecting mock session cookie documented \u2014 verify by reading test helper source"
      ],
      "passes": false
    },
    {
      "group": "Testing-Security",
      "feature": "Integration tests for API key routes and guard",
      "description": "Add integration tests in server/tests/api_key_tests.rs: (1) POST /api/v1/api-keys creates key and returns raw key once, (2) GET /api/v1/api-keys lists keys without hash, (3) DELETE /api/v1/api-keys/:id deletes own key, (4) DELETE /api/v1/api-keys/:id returns 403 for another user's key, (5) POST /api/v1/readings with valid X-API-Key header returns 201, (6) POST /api/v1/readings with invalid API key returns 401, (7) POST /api/v1/readings with expired API key returns 401 with 'API key expired' message. Use SeaORM mock or a test database.",
      "acceptance_criteria": [
        "server/tests/api_key_tests.rs exists with at least 7 test functions \u2014 verify with ls and count",
        "cargo test -p server api_key_tests passes \u2014 verify by running command",
        "Test verifying raw key returned only on creation passes \u2014 verify by running specific test",
        "Test verifying 403 on cross-user delete passes \u2014 verify by running specific test",
        "Test verifying expired key returns 401 with correct message passes \u2014 verify by running specific test",
        "cargo test --workspace passes \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Testing-Security",
      "feature": "Rate limiting and security headers tests",
      "description": "Add integration tests for security middleware in server/tests/security_tests.rs: (1) Verify all security headers present on any response (HSTS, X-Content-Type-Options, X-Frame-Options, CSP), (2) Verify CORS rejects requests from disallowed origins, (3) Verify CORS allows requests from FRONTEND_URL, (4) Verify rate limiting returns 429 after threshold exceeded on auth endpoints, (5) Verify Retry-After header present on 429 response. Use Rocket local client for header inspection.",
      "acceptance_criteria": [
        "server/tests/security_tests.rs exists with at least 5 test functions \u2014 verify with ls",
        "Security headers test verifies all 4 required headers present \u2014 verify by running test",
        "CORS origin rejection test passes \u2014 verify by running test",
        "Rate limit 429 test passes \u2014 verify by running test",
        "cargo test -p server security_tests passes \u2014 verify by running command"
      ],
      "passes": false
    },
    {
      "group": "Testing-Security",
      "feature": "Client API key integration test and deployment documentation",
      "description": "Add a justfile recipe `test-client-auth` that runs the client in simulate mode against a local server using a generated API key (created via curl, stored in a temp file, passed as --api-key). This verifies the full client\u2192server auth flow. Additionally, create docs/deployment-security.md documenting: (1) How to configure Authentik OAuth2 application (client ID, secret, redirect URI), (2) How to set all required env vars (AUTHENTIK_ISSUER_URL, AUTHENTIK_CLIENT_ID, AUTHENTIK_CLIENT_SECRET, FRONTEND_URL, ROCKET_SECRET_KEY), (3) How to generate and configure an API key for the Pi client, (4) How to rotate API keys without downtime.",
      "acceptance_criteria": [
        "just test-client-auth recipe exists in justfile \u2014 verify with just --list",
        "docs/deployment-security.md exists with all 4 documented sections \u2014 verify by reading file",
        "Authentik OAuth2 app configuration steps documented with required redirect URI format \u2014 verify by reading docs",
        "API key rotation procedure documented \u2014 verify by reading docs",
        "just test-client-auth runs without error against a local server \u2014 verify by running command"
      ],
      "passes": false
    }
  ]
}